#!/bin/bash -e

#-------------------------------------------------------------------------------------------------------
#
# From the cmdpost instance, setup the cluster VPC, and start the cluster admin, and bastion servers
#

eval "$(cli-shezargs $@)"

create_stack() {
  ra invoke "$(fn "$HOME/dev/" 'lib/ec2/cf\.js$')" createStack "$@"
}

peer_vpcs() {
  ra invoke "$(fn "$HOME/dev/" 'lib/ec2/cf\.js$')" peerVpcs "$@"
}

my_ip="$(curl -s http://169.254.169.254/latest/meta-data/local-ipv4)"

# Defaults
my_classb="$(echo $my_ip | cut -d'.' -f2)"


# ./build-cluster --namespace=serverassist --domain-name=mobilewebassist.net --hosted-zone=Z1CVBSGZ32XY1Z --dev-hosted-zone=Z2ARLLT5VWHYOH --cluster-classb=13 --prod-classb=12 --step1

[[ -z $namespace          ]] && die "Must provide --namespace="
[[ -z $domain_name        ]] && die "Must provide --domain-name="
[[ -z $hosted_zone        ]] && die "Must provide --hosted-zone="
[[ -z $dev_hosted_zone    ]] && die "Must provide --dev-hosted-zone="


if [[ -n $step1 ]]; then

  [[ -z $cluster_classb ]]  && die "Must provide --cluster-classb="
  [[ -z $prod_classb ]]     && die "Must provide --prod-classb="

  # Build the cluster stack -- 4 azs, all public
  create_stack --stack-name=${namespace}-cluster --namespace=${namespace} \
    --cidr=10.${cluster_classb}.0.0/16 \
    --domain-name=${domain_name} \
    --hosted-zone=${dev_hosted_zone} \
    --num-azs=4 \
    --num-subnets=3 \
    --cluster \
    --wait | tee /tmp/${namespace}-cluster.json | underscore print --color

  # Peer ourselves and the newly created cluster VPC
  peer_vpcs --from=${my_classb} --to=${cluster_classb} --wait | tee /tmp/peering-${my_classb}-to-${cluster_classb}.json | underscore print --color

  params="--color=green --image-id=xenial --bucket-namespace=mobilewebprint --classb=${cluster_classb} --namespace=${namespace}"
  params="${params} --stack=cluster --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 "

  (./boot-instance --key=HQ        --ip=10.13.0.251 --ruby    --instance-type=c4.xlarge --service=admin   --skip-ami ${params})

  # This version is good
  (./boot-instance --key=mario_demo --ip=10.13.1.3  --no-ruby --instance-type=t2.micro --service=bastione --skip-ami ${params})
#  (./boot-instance --key=mario_demo --ip=10.13.9.3  --no-ruby --instance-type=t2.micro --service=bastionb --skip-ami ${params})
#  (./boot-instance --key=mario_demo --ip=10.13.5.3  --no-ruby --instance-type=t2.micro --service=bastiond --skip-ami ${params})
#  (./boot-instance --key=mario_demo --ip=10.13.13.3 --no-ruby --instance-type=t2.micro --service=bastiona --skip-ami ${params})

  echo ""
  echo "The 'cluster' admin and bastion servers are up. Log into the admin and run step2"
  echo ""

  exit 0
fi


#-------------------------------------------------------------------------------------------------------
#
# Build the prod stack, and peer to it
#
#

#if [[ -n $step2 ]]; then

  [[ -z $cluster_classb ]]  && die "Must provide --cluster-classb="
  [[ -z $prod_classb ]]     && die "Must provide --prod-classb="
  [[ -z $our_vpc ]]         && die "Must provide --our-vpc="

  # Remember all the VPCs now, so we know which one is new
  aws ec2 describe-vpcs | underscore 'select' .VpcId | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/vpcs.txt

  # Build prod stack and wait
  create_stack --stack-name=${namespace}-pub --namespace=${namespace} \
    --cidr=10.${prod_classb}.0.0/16 \
    --domain-name=${domain_name} \
    --hosted-zone=${hosted_zone} \
    --num-azs=4 \
    --num-subnets=3 \
    --cluster \
    --session=$(echo $JSAWS_AWS_ACCT_EXTRA_CREDS | egrep -o 'pub:[^,]+' | cut -d':' -f1) \
    --account=$(echo $JSAWS_AWS_ACCT_EXTRA_CREDS | egrep -o 'pub:[^,]+' | cut -d':' -f2 | cut -d'/' -f1) \
    --role=$(echo $JSAWS_AWS_ACCT_EXTRA_CREDS | egrep -o 'pub:[^,]+' | cut -d'/' -f2) \
    --wait | tee /tmp/${namespace}-pub.json | underscore print --color

  # Get the list of VPCs, so we can figure out which one is new
  aws ec2 describe-vpcs | underscore 'select' .VpcId | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/vpcs2.txt

  printf "\n\nThe pub stack has just been created. Enter its VpcId\n"
  prod_vpc="$(diff /tmp/vpcs.txt /tmp/vpcs2.txt  | tr -d '< "' | egrep '^vpc' | head -1)"

#  read prod_vpc

  # Remember the peering info, so we can determine which is new later
  aws ec2 describe-vpc-peering-connections | underscore 'select' '.VpcPeeringConnectionId' | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/scratch-file.txt

  aws ec2 --region us-east-1 create-vpc-peering-connection --vpc-id $our_vpc --peer-vpc-id $prod_vpc --peer-owner-id 244406501905

  # Get the list of peering info, so we can see which one is new
  aws ec2 describe-vpc-peering-connections | underscore 'select' '.VpcPeeringConnectionId' | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/scratch-file2.txt

  printf "A PCX was just created. Accept it in the prod acct, and enter it here.\n"
  to_pcx="$(diff /tmp/scratch-file.txt /tmp/scratch-file2.txt  | tr -d '< "' | egrep '^vpc' | head -1)"
#  read to_pcx

echo $prod_vpc $to_pcx
exit

  peer_vpcs --to-pcx=${to_pcx} --from=${cluster_classb} --to-cidr=10.${prod_classb}.0.0/16 --wait
  peer_vpcs --to-pcx=${to_pcx} --from=${prod_classb} --to-cidr=10.${cluster_classb}.0.0/16 --wait --session=prod --acct=244406501905 --role=mario-mobilewebprint

#fi

#if [[ -n $step3 ]]; then

  [[ -z $test_classb ]]     && die "Must provide --test-classb="

  # Remember all the VPCs now, so we know which one is new
  aws ec2 describe-vpcs | underscore 'select' .VpcId | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/vpcs.txt

  # Build Test stack
  create_stack --stack-name=${namespace}-test${sub_name} --namespace=${namespace} \
    --cidr=10.${test_classb}.0.0/16 \
    --domain-name=${domain_name} \
    ${hosted_zone} \
    --num-azs=4 \
    --num-subnets=3 \
    --test \
    --wait | tee /tmp/${namespace}-test.json | underscore print --color

  # Get the list of VPCs, so we can figure out which one is new
  aws ec2 describe-vpcs | underscore 'select' .VpcId | tr -d ' ",[]' | egrep -v '^$' | sort > /tmp/vpcs2.txt

  test_vpc="$(diff /tmp/vpcs.txt /tmp/vpcs2.txt  | tr -d '< "' | egrep '^vpc' | head -1)"

  printf "\n\nThe test stack has just been created.  Press [ENTER] to continue...\n\n"
  read

  echo ""
  echo "The networking part of the non-prod infrastructure is up."
  echo "   Run step4 to peer test, prod."
  echo "   Run step5 to start needed cluster instances"
  echo "   Run step6 to start test instances"
  echo ""

#fi

#
#
# Connect test <-> prod
#
#

#if [[ -n $step4 ]]; then

  printf "Enter the test stack VpcId: "
#  read test_vpc

  printf "Enter the prod stack VpcId: "
#  read prod_vpc

  # -------- test <-> prod
  aws ec2 --region us-east-1 create-vpc-peering-connection --vpc-id $test_vpc --peer-vpc-id $prod_vpc --peer-owner-id 244406501905
  printf "A PCX was just created. Accept it in the prod account, and enter it here: "
  read test_and_prod_pcx

  peer_vpcs --to-pcx=${test_and_prod_pcx} --from=${test_classb} --to-cidr=10.${prod_classb}.0.0/16 --wait
  peer_vpcs --to-pcx=${test_and_prod_pcx} --from=${prod_classb} --to-cidr=10.${test_classb}.0.0/16 --wait --session=prod --acct=244406501905 --role=mario-mobilewebprint

#fi

exit 0

if [[ -n $step5 ]]; then

  [[ -z $cluster_classb ]]  && die "Must provide --cluster-classb="
  [[ -z $prod_classb ]]     && die "Must provide --prod-classb="

  # Finish building the cluster stack
  (cd .. && ./run-instances-from-amis --build-number=${build_number} --classb=${cluster_classb} --namespace=${namespace} --stack=cluster --my-env=development --db=10.${prod_classb}.21.220 --util==10.${prod_classb}.21.4)

  printf "\n\nThe cluster stack has just been deployed.\n\n"
fi

if [[ -n $step7 ]]; then

  [[ -z $prod_classb ]]     && die "Must provide --prod-classb="

  cd ..

  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green & sleep 30

  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t2 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t2 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t2 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t2 & sleep 30

  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t3 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t3 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t3 & sleep 30
  ./run-instances-from-amis --stack=pub --db=10.${prod_classb}.21.220 --util=10.${prod_classb}.21.4 --my-env=smprod --build-number=9899 --service=db --green-t3 &

  jobs
  wait

  echo "done."

fi



